From: Boyuan Yang <073plan@gmail.com>
Date: Tue, 5 Dec 2017 00:38:06 +0800
Subject: workaround: Provide private qt5xcbqpa headers

Qt in Debian cannot provide those headers for now (See Debian
Bug 883375) so we are including it here as a workaround.
---
 libqt5xcbqpa-dev/5.9.2/qxcbbackingstore.h      |  85 +++
 libqt5xcbqpa-dev/5.9.2/qxcbclipboard.h         | 119 ++++
 libqt5xcbqpa-dev/5.9.2/qxcbconnection.h        | 775 +++++++++++++++++++++++++
 libqt5xcbqpa-dev/5.9.2/qxcbcursor.h            | 115 ++++
 libqt5xcbqpa-dev/5.9.2/qxcbdrag.h              | 177 ++++++
 libqt5xcbqpa-dev/5.9.2/qxcbexport.h            |  55 ++
 libqt5xcbqpa-dev/5.9.2/qxcbimage.h             |  62 ++
 libqt5xcbqpa-dev/5.9.2/qxcbintegration.h       | 145 +++++
 libqt5xcbqpa-dev/5.9.2/qxcbkeyboard.h          | 151 +++++
 libqt5xcbqpa-dev/5.9.2/qxcbmime.h              |  75 +++
 libqt5xcbqpa-dev/5.9.2/qxcbnativeinterface.h   | 152 +++++
 libqt5xcbqpa-dev/5.9.2/qxcbobject.h            |  64 ++
 libqt5xcbqpa-dev/5.9.2/qxcbscreen.h            | 220 +++++++
 libqt5xcbqpa-dev/5.9.2/qxcbsessionmanager.h    |  96 +++
 libqt5xcbqpa-dev/5.9.2/qxcbsystemtraytracker.h |  85 +++
 libqt5xcbqpa-dev/5.9.2/qxcbwindow.h            | 297 ++++++++++
 libqt5xcbqpa-dev/5.9.2/qxcbwmsupport.h         |  68 +++
 libqt5xcbqpa-dev/5.9.2/qxcbxsettings.h         |  71 +++
 18 files changed, 2812 insertions(+)
 create mode 100644 libqt5xcbqpa-dev/5.9.2/qxcbbackingstore.h
 create mode 100644 libqt5xcbqpa-dev/5.9.2/qxcbclipboard.h
 create mode 100644 libqt5xcbqpa-dev/5.9.2/qxcbconnection.h
 create mode 100644 libqt5xcbqpa-dev/5.9.2/qxcbcursor.h
 create mode 100644 libqt5xcbqpa-dev/5.9.2/qxcbdrag.h
 create mode 100644 libqt5xcbqpa-dev/5.9.2/qxcbexport.h
 create mode 100644 libqt5xcbqpa-dev/5.9.2/qxcbimage.h
 create mode 100644 libqt5xcbqpa-dev/5.9.2/qxcbintegration.h
 create mode 100644 libqt5xcbqpa-dev/5.9.2/qxcbkeyboard.h
 create mode 100644 libqt5xcbqpa-dev/5.9.2/qxcbmime.h
 create mode 100644 libqt5xcbqpa-dev/5.9.2/qxcbnativeinterface.h
 create mode 100644 libqt5xcbqpa-dev/5.9.2/qxcbobject.h
 create mode 100644 libqt5xcbqpa-dev/5.9.2/qxcbscreen.h
 create mode 100644 libqt5xcbqpa-dev/5.9.2/qxcbsessionmanager.h
 create mode 100644 libqt5xcbqpa-dev/5.9.2/qxcbsystemtraytracker.h
 create mode 100644 libqt5xcbqpa-dev/5.9.2/qxcbwindow.h
 create mode 100644 libqt5xcbqpa-dev/5.9.2/qxcbwmsupport.h
 create mode 100644 libqt5xcbqpa-dev/5.9.2/qxcbxsettings.h

diff --git a/libqt5xcbqpa-dev/5.9.2/qxcbbackingstore.h b/libqt5xcbqpa-dev/5.9.2/qxcbbackingstore.h
new file mode 100644
index 0000000..94b5994
--- /dev/null
+++ b/libqt5xcbqpa-dev/5.9.2/qxcbbackingstore.h
@@ -0,0 +1,85 @@
+/****************************************************************************
+**
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QXCBBACKINGSTORE_H
+#define QXCBBACKINGSTORE_H
+
+#include <qpa/qplatformbackingstore.h>
+#include <QtCore/QStack>
+
+#include <xcb/xcb.h>
+
+#include "qxcbobject.h"
+
+QT_BEGIN_NAMESPACE
+
+class QXcbShmImage;
+
+class QXcbBackingStore : public QXcbObject, public QPlatformBackingStore
+{
+public:
+    QXcbBackingStore(QWindow *window);
+    ~QXcbBackingStore();
+
+    QPaintDevice *paintDevice() override;
+    void flush(QWindow *window, const QRegion &region, const QPoint &offset) override;
+#ifndef QT_NO_OPENGL
+    void composeAndFlush(QWindow *window, const QRegion &region, const QPoint &offset,
+                         QPlatformTextureList *textures, QOpenGLContext *context,
+                         bool translucentBackground) override;
+#endif
+    QImage toImage() const override;
+
+    QPlatformGraphicsBuffer *graphicsBuffer() const override;
+
+    void resize(const QSize &size, const QRegion &staticContents) override;
+    bool scroll(const QRegion &area, int dx, int dy) override;
+
+    void beginPaint(const QRegion &) override;
+    void endPaint() override;
+
+private:
+    QXcbShmImage *m_image;
+    QStack<QRegion> m_paintRegions;
+    QImage m_rgbImage;
+};
+
+QT_END_NAMESPACE
+
+#endif
diff --git a/libqt5xcbqpa-dev/5.9.2/qxcbclipboard.h b/libqt5xcbqpa-dev/5.9.2/qxcbclipboard.h
new file mode 100644
index 0000000..bfeae13
--- /dev/null
+++ b/libqt5xcbqpa-dev/5.9.2/qxcbclipboard.h
@@ -0,0 +1,119 @@
+/****************************************************************************
+**
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QXCBCLIPBOARD_H
+#define QXCBCLIPBOARD_H
+
+#include <qpa/qplatformclipboard.h>
+#include <qxcbobject.h>
+#include <xcb/xcb.h>
+#include <xcb/xfixes.h>
+
+QT_BEGIN_NAMESPACE
+
+#ifndef QT_NO_CLIPBOARD
+
+class QXcbConnection;
+class QXcbScreen;
+class QXcbClipboardMime;
+
+class QXcbClipboard : public QXcbObject, public QPlatformClipboard
+{
+public:
+    QXcbClipboard(QXcbConnection *connection);
+    ~QXcbClipboard();
+
+    QMimeData *mimeData(QClipboard::Mode mode) override;
+    void setMimeData(QMimeData *data, QClipboard::Mode mode) override;
+
+    bool supportsMode(QClipboard::Mode mode) const override;
+    bool ownsMode(QClipboard::Mode mode) const override;
+
+    QXcbScreen *screen() const;
+
+    xcb_window_t requestor() const;
+    void setRequestor(xcb_window_t window);
+
+    xcb_window_t owner() const;
+
+    void handleSelectionRequest(xcb_selection_request_event_t *event);
+    void handleSelectionClearRequest(xcb_selection_clear_event_t *event);
+    void handleXFixesSelectionRequest(xcb_xfixes_selection_notify_event_t *event);
+
+    bool clipboardReadProperty(xcb_window_t win, xcb_atom_t property, bool deleteProperty, QByteArray *buffer, int *size, xcb_atom_t *type, int *format);
+    QByteArray clipboardReadIncrementalProperty(xcb_window_t win, xcb_atom_t property, int nbytes, bool nullterm);
+
+    QByteArray getDataInFormat(xcb_atom_t modeAtom, xcb_atom_t fmtatom);
+
+    void setProcessIncr(bool process) { m_incr_active = process; }
+    bool processIncr() { return m_incr_active; }
+    void incrTransactionPeeker(xcb_generic_event_t *ge, bool &accepted);
+
+    xcb_window_t getSelectionOwner(xcb_atom_t atom) const;
+    QByteArray getSelection(xcb_atom_t selection, xcb_atom_t target, xcb_atom_t property, xcb_timestamp_t t = 0);
+
+private:
+    xcb_generic_event_t *waitForClipboardEvent(xcb_window_t win, int type, int timeout, bool checkManager = false);
+
+    xcb_atom_t sendTargetsSelection(QMimeData *d, xcb_window_t window, xcb_atom_t property);
+    xcb_atom_t sendSelection(QMimeData *d, xcb_atom_t target, xcb_window_t window, xcb_atom_t property);
+
+    xcb_atom_t atomForMode(QClipboard::Mode mode) const;
+    QClipboard::Mode modeForAtom(xcb_atom_t atom) const;
+
+    // Selection and Clipboard
+    QScopedPointer<QXcbClipboardMime> m_xClipboard[2];
+    QMimeData *m_clientClipboard[2];
+    xcb_timestamp_t m_timestamp[2];
+
+    xcb_window_t m_requestor = XCB_NONE;
+    xcb_window_t m_owner = XCB_NONE;
+
+    static const int clipboard_timeout;
+
+    bool m_incr_active = false;
+    bool m_clipboard_closing = false;
+    xcb_timestamp_t m_incr_receive_time = 0;
+};
+
+#endif // QT_NO_CLIPBOARD
+
+QT_END_NAMESPACE
+
+#endif // QXCBCLIPBOARD_H
diff --git a/libqt5xcbqpa-dev/5.9.2/qxcbconnection.h b/libqt5xcbqpa-dev/5.9.2/qxcbconnection.h
new file mode 100644
index 0000000..edbc8d8
--- /dev/null
+++ b/libqt5xcbqpa-dev/5.9.2/qxcbconnection.h
@@ -0,0 +1,775 @@
+/****************************************************************************
+**
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QXCBCONNECTION_H
+#define QXCBCONNECTION_H
+
+#include <xcb/xcb.h>
+#include <xcb/randr.h>
+
+#include <QtGui/private/qtguiglobal_p.h>
+#include "qxcbexport.h"
+#include <QHash>
+#include <QList>
+#include <QMutex>
+#include <QObject>
+#include <QThread>
+#include <QVector>
+#include <QVarLengthArray>
+#include <qpa/qwindowsysteminterface.h>
+#include <QtCore/QLoggingCategory>
+#include <QtCore/private/qglobal_p.h>
+
+// This is needed to make Qt compile together with XKB. xkb.h is using a variable
+// which is called 'explicit', this is a reserved keyword in c++
+#if QT_CONFIG(xkb)
+#define explicit dont_use_cxx_explicit
+#include <xcb/xkb.h>
+#undef explicit
+#endif
+
+#if QT_CONFIG(tabletevent)
+#include <QTabletEvent>
+#endif
+
+#if QT_CONFIG(xinput2)
+#include <X11/extensions/XI2.h>
+#ifdef XIScrollClass
+#define XCB_USE_XINPUT21    // XI 2.1 adds smooth scrolling support
+#ifdef XI_TouchBeginMask
+#define XCB_USE_XINPUT22    // XI 2.2 adds multi-point touch support
+#endif
+#endif
+struct XInput2TouchDeviceData;
+#endif // QT_CONFIG(xinput2)
+
+struct xcb_randr_get_output_info_reply_t;
+
+//#define Q_XCB_DEBUG
+
+QT_BEGIN_NAMESPACE
+
+Q_DECLARE_LOGGING_CATEGORY(lcQpaXInput)
+Q_DECLARE_LOGGING_CATEGORY(lcQpaXInputDevices)
+Q_DECLARE_LOGGING_CATEGORY(lcQpaXInputEvents)
+Q_DECLARE_LOGGING_CATEGORY(lcQpaScreen)
+
+class QXcbVirtualDesktop;
+class QXcbScreen;
+class QXcbWindow;
+class QXcbDrag;
+class QXcbKeyboard;
+class QXcbClipboard;
+class QXcbWMSupport;
+class QXcbNativeInterface;
+class QXcbSystemTrayTracker;
+class QXcbGlIntegration;
+
+namespace QXcbAtom {
+    enum Atom {
+        // window-manager <-> client protocols
+        WM_PROTOCOLS,
+        WM_DELETE_WINDOW,
+        WM_TAKE_FOCUS,
+        _NET_WM_PING,
+        _NET_WM_CONTEXT_HELP,
+        _NET_WM_SYNC_REQUEST,
+        _NET_WM_SYNC_REQUEST_COUNTER,
+        MANAGER, // System tray notification
+        _NET_SYSTEM_TRAY_OPCODE, // System tray operation
+
+        // ICCCM window state
+        WM_STATE,
+        WM_CHANGE_STATE,
+        WM_CLASS,
+        WM_NAME,
+
+        // Session management
+        WM_CLIENT_LEADER,
+        WM_WINDOW_ROLE,
+        SM_CLIENT_ID,
+
+        // Clipboard
+        CLIPBOARD,
+        INCR,
+        TARGETS,
+        MULTIPLE,
+        TIMESTAMP,
+        SAVE_TARGETS,
+        CLIP_TEMPORARY,
+        _QT_SELECTION,
+        _QT_CLIPBOARD_SENTINEL,
+        _QT_SELECTION_SENTINEL,
+        CLIPBOARD_MANAGER,
+
+        RESOURCE_MANAGER,
+
+        _XSETROOT_ID,
+
+        _QT_SCROLL_DONE,
+        _QT_INPUT_ENCODING,
+
+        // Qt/XCB specific
+        _QT_CLOSE_CONNECTION,
+
+        _MOTIF_WM_HINTS,
+
+        DTWM_IS_RUNNING,
+        ENLIGHTENMENT_DESKTOP,
+        _DT_SAVE_MODE,
+        _SGI_DESKS_MANAGER,
+
+        // EWMH (aka NETWM)
+        _NET_SUPPORTED,
+        _NET_VIRTUAL_ROOTS,
+        _NET_WORKAREA,
+
+        _NET_MOVERESIZE_WINDOW,
+        _NET_WM_MOVERESIZE,
+
+        _NET_WM_NAME,
+        _NET_WM_ICON_NAME,
+        _NET_WM_ICON,
+
+        _NET_WM_PID,
+
+        _NET_WM_WINDOW_OPACITY,
+
+        _NET_WM_STATE,
+        _NET_WM_STATE_ABOVE,
+        _NET_WM_STATE_BELOW,
+        _NET_WM_STATE_FULLSCREEN,
+        _NET_WM_STATE_MAXIMIZED_HORZ,
+        _NET_WM_STATE_MAXIMIZED_VERT,
+        _NET_WM_STATE_MODAL,
+        _NET_WM_STATE_STAYS_ON_TOP,
+        _NET_WM_STATE_DEMANDS_ATTENTION,
+
+        _NET_WM_USER_TIME,
+        _NET_WM_USER_TIME_WINDOW,
+        _NET_WM_FULL_PLACEMENT,
+
+        _NET_WM_WINDOW_TYPE,
+        _NET_WM_WINDOW_TYPE_DESKTOP,
+        _NET_WM_WINDOW_TYPE_DOCK,
+        _NET_WM_WINDOW_TYPE_TOOLBAR,
+        _NET_WM_WINDOW_TYPE_MENU,
+        _NET_WM_WINDOW_TYPE_UTILITY,
+        _NET_WM_WINDOW_TYPE_SPLASH,
+        _NET_WM_WINDOW_TYPE_DIALOG,
+        _NET_WM_WINDOW_TYPE_DROPDOWN_MENU,
+        _NET_WM_WINDOW_TYPE_POPUP_MENU,
+        _NET_WM_WINDOW_TYPE_TOOLTIP,
+        _NET_WM_WINDOW_TYPE_NOTIFICATION,
+        _NET_WM_WINDOW_TYPE_COMBO,
+        _NET_WM_WINDOW_TYPE_DND,
+        _NET_WM_WINDOW_TYPE_NORMAL,
+        _KDE_NET_WM_WINDOW_TYPE_OVERRIDE,
+
+        _KDE_NET_WM_FRAME_STRUT,
+        _NET_FRAME_EXTENTS,
+
+        _NET_STARTUP_INFO,
+        _NET_STARTUP_INFO_BEGIN,
+
+        _NET_SUPPORTING_WM_CHECK,
+
+        _NET_WM_CM_S0,
+
+        _NET_SYSTEM_TRAY_VISUAL,
+
+        _NET_ACTIVE_WINDOW,
+
+        // Property formats
+        TEXT,
+        UTF8_STRING,
+        CARDINAL,
+
+        // Xdnd
+        XdndEnter,
+        XdndPosition,
+        XdndStatus,
+        XdndLeave,
+        XdndDrop,
+        XdndFinished,
+        XdndTypelist,
+        XdndActionList,
+
+        XdndSelection,
+
+        XdndAware,
+        XdndProxy,
+
+        XdndActionCopy,
+        XdndActionLink,
+        XdndActionMove,
+        XdndActionPrivate,
+
+        // Motif DND
+        _MOTIF_DRAG_AND_DROP_MESSAGE,
+        _MOTIF_DRAG_INITIATOR_INFO,
+        _MOTIF_DRAG_RECEIVER_INFO,
+        _MOTIF_DRAG_WINDOW,
+        _MOTIF_DRAG_TARGETS,
+
+        XmTRANSFER_SUCCESS,
+        XmTRANSFER_FAILURE,
+
+        // Xkb
+        _XKB_RULES_NAMES,
+
+        // XEMBED
+        _XEMBED,
+        _XEMBED_INFO,
+
+        // XInput2
+        ButtonLeft,
+        ButtonMiddle,
+        ButtonRight,
+        ButtonWheelUp,
+        ButtonWheelDown,
+        ButtonHorizWheelLeft,
+        ButtonHorizWheelRight,
+        AbsMTPositionX,
+        AbsMTPositionY,
+        AbsMTTouchMajor,
+        AbsMTTouchMinor,
+        AbsMTOrientation,
+        AbsMTPressure,
+        AbsMTTrackingID,
+        MaxContacts,
+        RelX,
+        RelY,
+        // XInput2 tablet
+        AbsX,
+        AbsY,
+        AbsPressure,
+        AbsTiltX,
+        AbsTiltY,
+        AbsWheel,
+        AbsDistance,
+        WacomSerialIDs,
+        INTEGER,
+        RelHorizWheel,
+        RelVertWheel,
+        RelHorizScroll,
+        RelVertScroll,
+
+        _XSETTINGS_SETTINGS,
+
+        _COMPIZ_DECOR_PENDING,
+        _COMPIZ_DECOR_REQUEST,
+        _COMPIZ_DECOR_DELETE_PIXMAP,
+        _COMPIZ_TOOLKIT_ACTION,
+        _GTK_LOAD_ICONTHEMES,
+
+        NPredefinedAtoms,
+
+        _QT_SETTINGS_TIMESTAMP = NPredefinedAtoms,
+        NAtoms
+    };
+}
+
+typedef QVarLengthArray<xcb_generic_event_t *, 64> QXcbEventArray;
+
+class QXcbConnection;
+class QXcbEventReader : public QThread
+{
+    Q_OBJECT
+public:
+    QXcbEventReader(QXcbConnection *connection);
+
+    void run() override;
+
+    QXcbEventArray *lock();
+    void unlock();
+
+    void start();
+
+    void registerEventDispatcher(QAbstractEventDispatcher *dispatcher);
+
+signals:
+    void eventPending();
+
+private slots:
+    void registerForEvents();
+
+private:
+    void addEvent(xcb_generic_event_t *event);
+
+    QMutex m_mutex;
+    QXcbEventArray m_events;
+    QXcbConnection *m_connection;
+};
+
+class QXcbWindowEventListener
+{
+public:
+    virtual ~QXcbWindowEventListener() {}
+    virtual bool handleGenericEvent(xcb_generic_event_t *, long *) { return false; }
+
+    virtual void handleExposeEvent(const xcb_expose_event_t *) {}
+    virtual void handleClientMessageEvent(const xcb_client_message_event_t *) {}
+    virtual void handleConfigureNotifyEvent(const xcb_configure_notify_event_t *) {}
+    virtual void handleMapNotifyEvent(const xcb_map_notify_event_t *) {}
+    virtual void handleUnmapNotifyEvent(const xcb_unmap_notify_event_t *) {}
+    virtual void handleDestroyNotifyEvent(const xcb_destroy_notify_event_t *) {}
+    virtual void handleButtonPressEvent(const xcb_button_press_event_t *) {}
+    virtual void handleButtonReleaseEvent(const xcb_button_release_event_t *) {}
+    virtual void handleMotionNotifyEvent(const xcb_motion_notify_event_t *) {}
+    virtual void handleEnterNotifyEvent(const xcb_enter_notify_event_t *) {}
+    virtual void handleLeaveNotifyEvent(const xcb_leave_notify_event_t *) {}
+    virtual void handleFocusInEvent(const xcb_focus_in_event_t *) {}
+    virtual void handleFocusOutEvent(const xcb_focus_out_event_t *) {}
+    virtual void handlePropertyNotifyEvent(const xcb_property_notify_event_t *) {}
+#ifdef XCB_USE_XINPUT22
+    virtual void handleXIMouseEvent(xcb_ge_event_t *, Qt::MouseEventSource = Qt::MouseEventNotSynthesized) {}
+    virtual void handleXIEnterLeave(xcb_ge_event_t *) {}
+#endif
+    virtual QXcbWindow *toWindow() { return 0; }
+};
+
+typedef QHash<xcb_window_t, QXcbWindowEventListener *> WindowMapper;
+
+class QXcbSyncWindowRequest : public QEvent
+{
+public:
+    QXcbSyncWindowRequest(QXcbWindow *w) : QEvent(QEvent::Type(QEvent::User + 1)), m_window(w) { }
+
+    QXcbWindow *window() const { return m_window; }
+    void invalidate();
+
+private:
+    QXcbWindow *m_window;
+};
+
+class QAbstractEventDispatcher;
+class Q_XCB_EXPORT QXcbConnection : public QObject
+{
+    Q_OBJECT
+public:
+    QXcbConnection(QXcbNativeInterface *nativeInterface, bool canGrabServer, xcb_visualid_t defaultVisualId, const char *displayName = 0);
+    ~QXcbConnection();
+
+    QXcbConnection *connection() const { return const_cast<QXcbConnection *>(this); }
+    bool isConnected() const;
+
+    const QList<QXcbVirtualDesktop *> &virtualDesktops() const { return m_virtualDesktops; }
+    const QList<QXcbScreen *> &screens() const { return m_screens; }
+    int primaryScreenNumber() const { return m_primaryScreenNumber; }
+    QXcbVirtualDesktop *primaryVirtualDesktop() const { return m_virtualDesktops.value(m_primaryScreenNumber); }
+    QXcbScreen *primaryScreen() const;
+
+    inline xcb_atom_t atom(QXcbAtom::Atom atom) const { return m_allAtoms[atom]; }
+    QXcbAtom::Atom qatom(xcb_atom_t atom) const;
+    xcb_atom_t internAtom(const char *name);
+    QByteArray atomName(xcb_atom_t atom);
+
+    const char *displayName() const { return m_displayName.constData(); }
+    xcb_connection_t *xcb_connection() const { return m_connection; }
+    const xcb_setup_t *setup() const { return m_setup; }
+    const xcb_format_t *formatForDepth(uint8_t depth) const;
+
+    QXcbKeyboard *keyboard() const { return m_keyboard; }
+
+#ifndef QT_NO_CLIPBOARD
+    QXcbClipboard *clipboard() const { return m_clipboard; }
+#endif
+#ifndef QT_NO_DRAGANDDROP
+    QXcbDrag *drag() const { return m_drag; }
+#endif
+
+    QXcbWMSupport *wmSupport() const { return m_wmSupport.data(); }
+    xcb_window_t rootWindow();
+    xcb_window_t clientLeader();
+
+    bool hasDefaultVisualId() const { return m_defaultVisualId != UINT_MAX; }
+    xcb_visualid_t defaultVisualId() const { return m_defaultVisualId; }
+
+#if QT_CONFIG(xcb_xlib)
+    void *xlib_display() const;
+    void *createVisualInfoForDefaultVisualId() const;
+#endif
+
+#if QT_CONFIG(xinput2)
+    void xi2Select(xcb_window_t window);
+    void xi2SelectStateEvents();
+#endif
+#ifdef XCB_USE_XINPUT21
+    bool isAtLeastXI21() const { return m_xi2Enabled && m_xi2Minor >= 1; }
+#else
+    bool isAtLeastXI21() const { return false; }
+#endif
+#ifdef XCB_USE_XINPUT22
+    bool isAtLeastXI22() const { return m_xi2Enabled && m_xi2Minor >= 2; }
+#else
+    bool isAtLeastXI22() const { return false; }
+#endif
+
+    void sync();
+
+    void handleXcbError(xcb_generic_error_t *error);
+    void handleXcbEvent(xcb_generic_event_t *event);
+
+    void addWindowEventListener(xcb_window_t id, QXcbWindowEventListener *eventListener);
+    void removeWindowEventListener(xcb_window_t id);
+    QXcbWindowEventListener *windowEventListenerFromId(xcb_window_t id);
+    QXcbWindow *platformWindowFromId(xcb_window_t id);
+
+    template<typename T>
+    inline xcb_generic_event_t *checkEvent(T &checker);
+
+    typedef bool (*PeekFunc)(QXcbConnection *, xcb_generic_event_t *);
+    void addPeekFunc(PeekFunc f);
+
+    inline xcb_timestamp_t time() const { return m_time; }
+    inline void setTime(xcb_timestamp_t t) { if (t > m_time) m_time = t; }
+
+    inline xcb_timestamp_t netWmUserTime() const { return m_netWmUserTime; }
+    inline void setNetWmUserTime(xcb_timestamp_t t) { if (t > m_netWmUserTime) m_netWmUserTime = t; }
+
+    bool hasXFixes() const { return xfixes_first_event > 0; }
+    bool hasXShape() const { return has_shape_extension; }
+    bool hasXRandr() const { return has_randr_extension; }
+    bool hasInputShape() const { return has_input_shape; }
+    bool hasXKB() const { return has_xkb; }
+
+    bool supportsThreadedRendering() const { return m_reader->isRunning(); }
+    bool threadedEventHandling() const { return m_reader->isRunning(); }
+
+    xcb_timestamp_t getTimestamp();
+    xcb_window_t getSelectionOwner(xcb_atom_t atom) const;
+    xcb_window_t getQtSelectionOwner();
+
+    void setButton(Qt::MouseButton button, bool down) { m_buttons.setFlag(button, down); }
+    Qt::MouseButtons buttons() const { return m_buttons; }
+    Qt::MouseButton translateMouseButton(xcb_button_t s);
+
+    QXcbWindow *focusWindow() const { return m_focusWindow; }
+    void setFocusWindow(QWindow *);
+    QXcbWindow *mouseGrabber() const { return m_mouseGrabber; }
+    void setMouseGrabber(QXcbWindow *);
+    QXcbWindow *mousePressWindow() const { return m_mousePressWindow; }
+    void setMousePressWindow(QXcbWindow *);
+
+    QByteArray startupId() const { return m_startupId; }
+    void setStartupId(const QByteArray &nextId) { m_startupId = nextId; }
+    void clearStartupId() { m_startupId.clear(); }
+
+    void grabServer();
+    void ungrabServer();
+
+    QXcbNativeInterface *nativeInterface() const { return m_nativeInterface; }
+
+    QXcbSystemTrayTracker *systemTrayTracker() const;
+    static bool xEmbedSystemTrayAvailable();
+    static bool xEmbedSystemTrayVisualHasAlphaChannel();
+
+#ifdef XCB_USE_XINPUT21
+    void handleEnterEvent();
+#endif
+
+#ifdef XCB_USE_XINPUT22
+    bool startSystemResizeForTouchBegin(xcb_window_t window, const QPoint &point, Qt::Corner corner);
+    bool xi2SetMouseGrabEnabled(xcb_window_t w, bool grab);
+#endif
+    Qt::MouseButton xiToQtMouseButton(uint32_t b);
+
+    QXcbEventReader *eventReader() const { return m_reader; }
+
+    bool canGrab() const { return m_canGrabServer; }
+
+    QXcbGlIntegration *glIntegration() const { return m_glIntegration; }
+
+#ifdef XCB_USE_XINPUT22
+    bool xi2MouseEvents() const;
+    bool isTouchScreen(int id) const;
+#endif
+
+protected:
+    bool event(QEvent *e) override;
+
+public slots:
+    void flush() { xcb_flush(m_connection); }
+
+private slots:
+    void processXcbEvents();
+
+private:
+    void initializeAllAtoms();
+    void sendConnectionEvent(QXcbAtom::Atom atom, uint id = 0);
+    void initializeXFixes();
+    void initializeXRender();
+    void initializeXRandr();
+    void initializeXinerama();
+    void initializeXShape();
+    void initializeXKB();
+    void handleClientMessageEvent(const xcb_client_message_event_t *event);
+    QXcbScreen* findScreenForCrtc(xcb_window_t rootWindow, xcb_randr_crtc_t crtc) const;
+    QXcbScreen* findScreenForOutput(xcb_window_t rootWindow, xcb_randr_output_t output) const;
+    QXcbVirtualDesktop* virtualDesktopForRootWindow(xcb_window_t rootWindow) const;
+    void updateScreens(const xcb_randr_notify_event_t *event);
+    bool checkOutputIsPrimary(xcb_window_t rootWindow, xcb_randr_output_t output);
+    void updateScreen(QXcbScreen *screen, const xcb_randr_output_change_t &outputChange);
+    QXcbScreen *createScreen(QXcbVirtualDesktop *virtualDesktop,
+                             const xcb_randr_output_change_t &outputChange,
+                             xcb_randr_get_output_info_reply_t *outputInfo);
+    void destroyScreen(QXcbScreen *screen);
+    void initializeScreens();
+    bool compressEvent(xcb_generic_event_t *event, int currentIndex, QXcbEventArray *eventqueue) const;
+#if QT_CONFIG(xinput2)
+    bool m_xi2Enabled = false;
+    int m_xi2Minor = 2;
+    void initializeXInput2();
+    void finalizeXInput2();
+    void xi2SetupDevices();
+    XInput2TouchDeviceData *touchDeviceForId(int id);
+    void xi2HandleEvent(xcb_ge_event_t *event);
+    void xi2HandleHierachyEvent(void *event);
+    void xi2HandleDeviceChangedEvent(void *event);
+    int m_xiOpCode, m_xiEventBase, m_xiErrorBase;
+#ifdef XCB_USE_XINPUT22
+    void xi2ProcessTouch(void *xiDevEvent, QXcbWindow *platformWindow);
+#endif // XCB_USE_XINPUT22
+#if QT_CONFIG(tabletevent)
+    struct TabletData {
+        int deviceId = 0;
+        QTabletEvent::PointerType pointerType = QTabletEvent::UnknownPointer;
+        QTabletEvent::TabletDevice tool = QTabletEvent::Stylus;
+        Qt::MouseButtons buttons = 0;
+        qint64 serialId = 0;
+        bool inProximity = false;
+        struct ValuatorClassInfo {
+            double minVal = 0;
+            double maxVal = 0;
+            double curVal = 0;
+            int number = -1;
+        };
+        QHash<int, ValuatorClassInfo> valuatorInfo;
+    };
+    friend class QTypeInfo<TabletData>;
+    friend class QTypeInfo<TabletData::ValuatorClassInfo>;
+    bool xi2HandleTabletEvent(const void *event, TabletData *tabletData);
+    void xi2ReportTabletEvent(const void *event, TabletData *tabletData);
+    QVector<TabletData> m_tabletData;
+    TabletData *tabletDataForDevice(int id);
+#endif // QT_CONFIG(tabletevent)
+    struct ScrollingDevice {
+        int deviceId = 0;
+        int verticalIndex = 0;
+        int horizontalIndex = 0;
+        double verticalIncrement = 0;
+        double horizontalIncrement = 0;
+        Qt::Orientations orientations = 0;
+        Qt::Orientations legacyOrientations = 0;
+        QPointF lastScrollPosition;
+    };
+    void updateScrollingDevice(ScrollingDevice& scrollingDevice, int num_classes, void *classes);
+    void xi2HandleScrollEvent(void *event, ScrollingDevice &scrollingDevice);
+    QHash<int, ScrollingDevice> m_scrollingDevices;
+
+    static bool xi2GetValuatorValueIfSet(const void *event, int valuatorNum, double *value);
+    static void xi2PrepareXIGenericDeviceEvent(xcb_ge_event_t *event);
+#endif
+
+    xcb_connection_t *m_connection = nullptr;
+    const xcb_setup_t *m_setup = nullptr;
+    const bool m_canGrabServer;
+    const xcb_visualid_t m_defaultVisualId;
+
+    QList<QXcbVirtualDesktop *> m_virtualDesktops;
+    QList<QXcbScreen *> m_screens;
+    int m_primaryScreenNumber = 0;
+
+    xcb_atom_t m_allAtoms[QXcbAtom::NAtoms];
+
+    xcb_timestamp_t m_time = XCB_CURRENT_TIME;
+    xcb_timestamp_t m_netWmUserTime = XCB_CURRENT_TIME;
+
+    QByteArray m_displayName;
+
+    QXcbKeyboard *m_keyboard = nullptr;
+#ifndef QT_NO_CLIPBOARD
+    QXcbClipboard *m_clipboard = nullptr;
+#endif
+#ifndef QT_NO_DRAGANDDROP
+    QXcbDrag *m_drag = nullptr;
+#endif
+    QScopedPointer<QXcbWMSupport> m_wmSupport;
+    QXcbNativeInterface *m_nativeInterface = nullptr;
+
+#if QT_CONFIG(xcb_xlib)
+    void *m_xlib_display = nullptr;
+#endif
+    QXcbEventReader *m_reader = nullptr;
+#if QT_CONFIG(xinput2)
+    QHash<int, XInput2TouchDeviceData*> m_touchDevices;
+#ifdef XCB_USE_XINPUT22
+    struct StartSystemResizeInfo {
+        xcb_window_t window;
+        uint16_t deviceid;
+        uint32_t pointid;
+        Qt::Corner corner;
+    } m_startSystemResizeInfo;
+#endif
+#endif
+#ifdef Q_XCB_DEBUG
+    struct CallInfo {
+        int sequence;
+        QByteArray file;
+        int line;
+    };
+    QVector<CallInfo> m_callLog;
+    QMutex m_callLogMutex;
+    void log(const char *file, int line, int sequence);
+    template <typename cookie_t>
+    friend cookie_t q_xcb_call_template(const cookie_t &cookie, QXcbConnection *connection,
+                                        const char *file, int line);
+    template <typename reply_t>
+    friend reply_t *q_xcb_call_template(reply_t *reply, QXcbConnection *connection,
+                                        const char *file, int line);
+#endif
+
+    WindowMapper m_mapper;
+
+    QVector<PeekFunc> m_peekFuncs;
+
+    uint32_t xfixes_first_event = 0;
+    uint32_t xrandr_first_event = 0;
+    uint32_t xkb_first_event = 0;
+
+    bool has_xinerama_extension = false;
+    bool has_shape_extension = false;
+    bool has_randr_extension = false;
+    bool has_input_shape;
+    bool has_xkb = false;
+
+    Qt::MouseButtons m_buttons = 0;
+
+    QXcbWindow *m_focusWindow = nullptr;
+    QXcbWindow *m_mouseGrabber = nullptr;
+    QXcbWindow *m_mousePressWindow = nullptr;
+
+    xcb_window_t m_clientLeader = 0;
+    QByteArray m_startupId;
+    QXcbSystemTrayTracker *m_systemTrayTracker = nullptr;
+    QXcbGlIntegration *m_glIntegration = nullptr;
+    bool m_xiGrab = false;
+
+    xcb_window_t m_qtSelectionOwner = 0;
+
+    friend class QXcbEventReader;
+};
+#if QT_CONFIG(xinput2)
+#if QT_CONFIG(tabletevent)
+Q_DECLARE_TYPEINFO(QXcbConnection::TabletData::ValuatorClassInfo, Q_PRIMITIVE_TYPE);
+Q_DECLARE_TYPEINFO(QXcbConnection::TabletData, Q_MOVABLE_TYPE);
+#endif
+#endif
+
+#define DISPLAY_FROM_XCB(object) (reinterpret_cast<Display *>(object->connection()->xlib_display()))
+#define CREATE_VISUALINFO_FROM_DEFAULT_VISUALID(object) ((XVisualInfo *)(object->connection()->createVisualInfoForDefaultVisualId()))
+
+template<typename T>
+xcb_generic_event_t *QXcbConnection::checkEvent(T &checker)
+{
+    QXcbEventArray *eventqueue = m_reader->lock();
+
+    for (int i = 0; i < eventqueue->size(); ++i) {
+        xcb_generic_event_t *event = eventqueue->at(i);
+        if (checker.checkEvent(event)) {
+            (*eventqueue)[i] = 0;
+            m_reader->unlock();
+            return event;
+        }
+    }
+    m_reader->unlock();
+    return 0;
+}
+
+class QXcbConnectionGrabber
+{
+public:
+    QXcbConnectionGrabber(QXcbConnection *connection);
+    ~QXcbConnectionGrabber();
+    void release();
+private:
+    QXcbConnection *m_connection;
+};
+
+template <typename T>
+union q_padded_xcb_event {
+  T event;
+  char padding[32];
+};
+
+// The xcb_send_event() requires all events to have 32 bytes. It calls memcpy() on the
+// passed in event. If the passed in event is less than 32 bytes, memcpy() reaches into
+// unrelated memory.
+#define Q_DECLARE_XCB_EVENT(event_var, event_type) \
+    q_padded_xcb_event<event_type> store = {}; \
+    auto &event_var = store.event;
+
+#ifdef Q_XCB_DEBUG
+template <typename cookie_t>
+cookie_t q_xcb_call_template(const cookie_t &cookie, QXcbConnection *connection, const char *file,
+                             int line)
+{
+    connection->log(file, line, cookie.sequence);
+    return cookie;
+}
+
+template <typename reply_t>
+reply_t *q_xcb_call_template(reply_t *reply, QXcbConnection *connection, const char *file, int line)
+{
+    connection->log(file, line, reply->sequence);
+    return reply;
+}
+#define Q_XCB_CALL(x) q_xcb_call_template(x, connection(), __FILE__, __LINE__)
+#define Q_XCB_CALL2(x, connection) q_xcb_call_template(x, connection, __FILE__, __LINE__)
+#define Q_XCB_NOOP(c) q_xcb_call_template(xcb_no_operation(c->xcb_connection()), c, __FILE__, __LINE__);
+#else
+#define Q_XCB_CALL(x) x
+#define Q_XCB_CALL2(x, connection) x
+#define Q_XCB_NOOP(c) (void)c;
+#endif
+
+QT_END_NAMESPACE
+
+#endif
diff --git a/libqt5xcbqpa-dev/5.9.2/qxcbcursor.h b/libqt5xcbqpa-dev/5.9.2/qxcbcursor.h
new file mode 100644
index 0000000..e3f8851
--- /dev/null
+++ b/libqt5xcbqpa-dev/5.9.2/qxcbcursor.h
@@ -0,0 +1,115 @@
+/****************************************************************************
+**
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QXCBCURSOR_H
+#define QXCBCURSOR_H
+
+#include <qpa/qplatformcursor.h>
+#include "qxcbscreen.h"
+
+QT_BEGIN_NAMESPACE
+
+#ifndef QT_NO_CURSOR
+
+struct QXcbCursorCacheKey
+{
+    explicit QXcbCursorCacheKey(const QCursor &c);
+    explicit QXcbCursorCacheKey(Qt::CursorShape s) : shape(s), bitmapCacheKey(0), maskCacheKey(0) {}
+    QXcbCursorCacheKey() : shape(Qt::CustomCursor), bitmapCacheKey(0), maskCacheKey(0) {}
+
+    Qt::CursorShape shape;
+    qint64 bitmapCacheKey;
+    qint64 maskCacheKey;
+};
+
+inline bool operator==(const QXcbCursorCacheKey &k1, const QXcbCursorCacheKey &k2)
+{
+    return k1.shape == k2.shape && k1.bitmapCacheKey == k2.bitmapCacheKey && k1.maskCacheKey == k2.maskCacheKey;
+}
+
+inline uint qHash(const QXcbCursorCacheKey &k, uint seed) Q_DECL_NOTHROW
+{
+    return (uint(k.shape) + uint(k.bitmapCacheKey) + uint(k.maskCacheKey)) ^ seed;
+}
+
+#endif // !QT_NO_CURSOR
+
+class QXcbCursor : public QXcbObject, public QPlatformCursor
+{
+public:
+    QXcbCursor(QXcbConnection *conn, QXcbScreen *screen);
+    ~QXcbCursor();
+#ifndef QT_NO_CURSOR
+    void changeCursor(QCursor *cursor, QWindow *widget) override;
+#endif
+    QPoint pos() const override;
+    void setPos(const QPoint &pos) override;
+
+    static void queryPointer(QXcbConnection *c, QXcbVirtualDesktop **virtualDesktop, QPoint *pos, int *keybMask = 0);
+
+#ifndef QT_NO_CURSOR
+    xcb_cursor_t xcbCursor(const QCursor &c) const
+        { return m_cursorHash.value(QXcbCursorCacheKey(c), xcb_cursor_t(0)); }
+#endif
+
+private:
+#ifndef QT_NO_CURSOR
+    typedef QHash<QXcbCursorCacheKey, xcb_cursor_t> CursorHash;
+
+    xcb_cursor_t createFontCursor(int cshape);
+    xcb_cursor_t createBitmapCursor(QCursor *cursor);
+    xcb_cursor_t createNonStandardCursor(int cshape);
+#endif
+
+    QXcbScreen *m_screen;
+#ifndef QT_NO_CURSOR
+    CursorHash m_cursorHash;
+#endif
+#if QT_CONFIG(xcb_xlib) && QT_CONFIG(library)
+    static void cursorThemePropertyChanged(QXcbVirtualDesktop *screen,
+                                           const QByteArray &name,
+                                           const QVariant &property,
+                                           void *handle);
+#endif
+    bool m_gtkCursorThemeInitialized;
+};
+
+QT_END_NAMESPACE
+
+#endif
diff --git a/libqt5xcbqpa-dev/5.9.2/qxcbdrag.h b/libqt5xcbqpa-dev/5.9.2/qxcbdrag.h
new file mode 100644
index 0000000..2d152ed
--- /dev/null
+++ b/libqt5xcbqpa-dev/5.9.2/qxcbdrag.h
@@ -0,0 +1,177 @@
+/****************************************************************************
+**
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QXCBDRAG_H
+#define QXCBDRAG_H
+
+#include <qpa/qplatformdrag.h>
+#include <private/qsimpledrag_p.h>
+#include <qxcbobject.h>
+#include <xcb/xcb.h>
+#include <qpoint.h>
+#include <qrect.h>
+#include <qsharedpointer.h>
+#include <qpointer.h>
+#include <qvector.h>
+#include <qdatetime.h>
+#include <qpixmap.h>
+#include <qbackingstore.h>
+
+#include <QtCore/QDebug>
+
+QT_BEGIN_NAMESPACE
+
+#ifndef QT_NO_DRAGANDDROP
+
+class QWindow;
+class QPlatformWindow;
+class QXcbConnection;
+class QXcbWindow;
+class QXcbDropData;
+class QXcbScreen;
+class QDrag;
+class QShapedPixmapWindow;
+
+class QXcbDrag : public QXcbObject, public QBasicDrag
+{
+public:
+    QXcbDrag(QXcbConnection *c);
+    ~QXcbDrag();
+
+    QMimeData *platformDropData() override;
+    bool eventFilter(QObject *o, QEvent *e) override;
+
+    void startDrag() override;
+    void cancel() override;
+    void move(const QPoint &globalPos) override;
+    void drop(const QPoint &globalPos) override;
+    void endDrag() override;
+
+    void handleEnter(QPlatformWindow *window, const xcb_client_message_event_t *event, xcb_window_t proxy = 0);
+    void handlePosition(QPlatformWindow *w, const xcb_client_message_event_t *event);
+    void handleLeave(QPlatformWindow *w, const xcb_client_message_event_t *event);
+    void handleDrop(QPlatformWindow *, const xcb_client_message_event_t *event);
+
+    void handleStatus(const xcb_client_message_event_t *event);
+    void handleSelectionRequest(const xcb_selection_request_event_t *event);
+    void handleFinished(const xcb_client_message_event_t *event);
+
+    bool dndEnable(QXcbWindow *win, bool on);
+    bool ownsDragObject() const override;
+
+    void updatePixmap();
+    xcb_timestamp_t targetTime() { return target_time; }
+
+protected:
+    void timerEvent(QTimerEvent* e) override;
+
+private:
+    friend class QXcbDropData;
+
+    void init();
+
+    void handle_xdnd_position(QPlatformWindow *w, const xcb_client_message_event_t *event);
+    void handle_xdnd_status(const xcb_client_message_event_t *event);
+    void send_leave();
+
+    Qt::DropAction toDropAction(xcb_atom_t atom) const;
+    xcb_atom_t toXdndAction(Qt::DropAction a) const;
+
+    QPointer<QWindow> initiatorWindow;
+    QPointer<QWindow> currentWindow;
+    QPoint currentPosition;
+
+    QXcbDropData *dropData;
+    Qt::DropAction accepted_drop_action;
+
+    QWindow *desktop_proxy;
+
+    xcb_atom_t xdnd_dragsource;
+
+    // the types in this drop. 100 is no good, but at least it's big.
+    enum { xdnd_max_type = 100 };
+    QVector<xcb_atom_t> xdnd_types;
+
+    // timestamp from XdndPosition and XdndDroptime for retrieving the data
+    xcb_timestamp_t target_time;
+    xcb_timestamp_t source_time;
+
+    // rectangle in which the answer will be the same
+    QRect source_sameanswer;
+    bool waiting_for_status;
+
+    // top-level window we sent position to last.
+    xcb_window_t current_target;
+    // window to send events to (always valid if current_target)
+    xcb_window_t current_proxy_target;
+
+    QXcbVirtualDesktop *current_virtual_desktop;
+
+    // 10 minute timer used to discard old XdndDrop transactions
+    enum { XdndDropTransactionTimeout = 600000 };
+    int cleanup_timer;
+
+    QVector<xcb_atom_t> drag_types;
+
+    struct Transaction
+    {
+        xcb_timestamp_t timestamp;
+        xcb_window_t target;
+        xcb_window_t proxy_target;
+        QPlatformWindow *targetWindow;
+//        QWidget *embedding_widget;
+        QPointer<QDrag> drag;
+        QTime time;
+    };
+    friend class QTypeInfo<Transaction>;
+    QVector<Transaction> transactions;
+
+    int transaction_expiry_timer;
+    void restartDropExpiryTimer();
+    int findTransactionByWindow(xcb_window_t window);
+    int findTransactionByTime(xcb_timestamp_t timestamp);
+    xcb_window_t findRealWindow(const QPoint & pos, xcb_window_t w, int md, bool ignoreNonXdndAwareWindows);
+};
+Q_DECLARE_TYPEINFO(QXcbDrag::Transaction, Q_MOVABLE_TYPE);
+
+#endif // QT_NO_DRAGANDDROP
+
+QT_END_NAMESPACE
+
+#endif
diff --git a/libqt5xcbqpa-dev/5.9.2/qxcbexport.h b/libqt5xcbqpa-dev/5.9.2/qxcbexport.h
new file mode 100644
index 0000000..4db23a9
--- /dev/null
+++ b/libqt5xcbqpa-dev/5.9.2/qxcbexport.h
@@ -0,0 +1,55 @@
+/****************************************************************************
+**
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QXCBEXPORT_H
+#define QXCBEXPORT_H
+
+#include <QtCore/qglobal.h>
+
+QT_BEGIN_NAMESPACE
+
+#  if defined(QT_BUILD_XCB_PLUGIN)
+#    define Q_XCB_EXPORT Q_DECL_EXPORT
+#  else
+#    define Q_XCB_EXPORT Q_DECL_IMPORT
+#  endif
+
+QT_END_NAMESPACE
+#endif //QXCBEXPORT_H
+
diff --git a/libqt5xcbqpa-dev/5.9.2/qxcbimage.h b/libqt5xcbqpa-dev/5.9.2/qxcbimage.h
new file mode 100644
index 0000000..a9071a4
--- /dev/null
+++ b/libqt5xcbqpa-dev/5.9.2/qxcbimage.h
@@ -0,0 +1,62 @@
+/****************************************************************************
+**
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QXCBIMAGE_H
+#define QXCBIMAGE_H
+
+#include "qxcbscreen.h"
+#include <QtCore/QPair>
+#include <QtGui/QImage>
+#include <QtGui/QPixmap>
+#include <xcb/xcb_image.h>
+
+QT_BEGIN_NAMESPACE
+
+QImage::Format qt_xcb_imageFormatForVisual(QXcbConnection *connection,
+                                           uint8_t depth, const xcb_visualtype_t *visual);
+QPixmap qt_xcb_pixmapFromXPixmap(QXcbConnection *connection, xcb_pixmap_t pixmap,
+                                 int width, int height, int depth,
+                                 const xcb_visualtype_t *visual);
+xcb_pixmap_t qt_xcb_XPixmapFromBitmap(QXcbScreen *screen, const QImage &image);
+xcb_cursor_t qt_xcb_createCursorXRender(QXcbScreen *screen, const QImage &image,
+                                        const QPoint &spot);
+
+QT_END_NAMESPACE
+
+#endif
diff --git a/libqt5xcbqpa-dev/5.9.2/qxcbintegration.h b/libqt5xcbqpa-dev/5.9.2/qxcbintegration.h
new file mode 100644
index 0000000..b3d72c1
--- /dev/null
+++ b/libqt5xcbqpa-dev/5.9.2/qxcbintegration.h
@@ -0,0 +1,145 @@
+/****************************************************************************
+**
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QXCBINTEGRATION_H
+#define QXCBINTEGRATION_H
+
+#include <QtGui/private/qtguiglobal_p.h>
+#include <qpa/qplatformintegration.h>
+#include <qpa/qplatformscreen.h>
+
+#include "qxcbexport.h"
+
+#include <xcb/xcb.h>
+
+QT_BEGIN_NAMESPACE
+
+class QXcbConnection;
+class QAbstractEventDispatcher;
+class QXcbNativeInterface;
+class QXcbScreen;
+
+class Q_XCB_EXPORT QXcbIntegration : public QPlatformIntegration
+{
+public:
+    QXcbIntegration(const QStringList &parameters, int &argc, char **argv);
+    ~QXcbIntegration();
+
+    QPlatformWindow *createPlatformWindow(QWindow *window) const override;
+    QPlatformWindow *createForeignWindow(QWindow *window, WId nativeHandle) const override;
+#ifndef QT_NO_OPENGL
+    QPlatformOpenGLContext *createPlatformOpenGLContext(QOpenGLContext *context) const override;
+#endif
+    QPlatformBackingStore *createPlatformBackingStore(QWindow *window) const override;
+
+    QPlatformOffscreenSurface *createPlatformOffscreenSurface(QOffscreenSurface *surface) const override;
+
+    bool hasCapability(Capability cap) const override;
+    QAbstractEventDispatcher *createEventDispatcher() const override;
+    void initialize() override;
+
+    void moveToScreen(QWindow *window, int screen);
+
+    QPlatformFontDatabase *fontDatabase() const override;
+
+    QPlatformNativeInterface *nativeInterface()const override;
+
+#ifndef QT_NO_CLIPBOARD
+    QPlatformClipboard *clipboard() const override;
+#endif
+#ifndef QT_NO_DRAGANDDROP
+    QPlatformDrag *drag() const override;
+#endif
+
+    QPlatformInputContext *inputContext() const override;
+
+#ifndef QT_NO_ACCESSIBILITY
+    QPlatformAccessibility *accessibility() const override;
+#endif
+
+    QPlatformServices *services() const override;
+
+    Qt::KeyboardModifiers queryKeyboardModifiers() const override;
+    QList<int> possibleKeys(const QKeyEvent *e) const override;
+
+    QStringList themeNames() const override;
+    QPlatformTheme *createPlatformTheme(const QString &name) const override;
+    QVariant styleHint(StyleHint hint) const override;
+
+    QXcbConnection *defaultConnection() const { return m_connections.first(); }
+
+    QByteArray wmClass() const;
+
+#if QT_CONFIG(xcb_sm)
+    QPlatformSessionManager *createPlatformSessionManager(const QString &id, const QString &key) const override;
+#endif
+
+    void sync() override;
+
+    void beep() const override;
+
+    static QXcbIntegration *instance() { return m_instance; }
+
+private:
+    QList<QXcbConnection *> m_connections;
+
+    QScopedPointer<QPlatformFontDatabase> m_fontDatabase;
+    QScopedPointer<QXcbNativeInterface> m_nativeInterface;
+
+    QScopedPointer<QPlatformInputContext> m_inputContext;
+
+#ifndef QT_NO_ACCESSIBILITY
+    mutable QScopedPointer<QPlatformAccessibility> m_accessibility;
+#endif
+
+    QScopedPointer<QPlatformServices> m_services;
+
+    friend class QXcbConnection; // access QPlatformIntegration::screenAdded()
+
+    mutable QByteArray m_wmClass;
+    const char *m_instanceName;
+    bool m_canGrab;
+    xcb_visualid_t m_defaultVisualId;
+
+    static QXcbIntegration *m_instance;
+};
+
+QT_END_NAMESPACE
+
+#endif
diff --git a/libqt5xcbqpa-dev/5.9.2/qxcbkeyboard.h b/libqt5xcbqpa-dev/5.9.2/qxcbkeyboard.h
new file mode 100644
index 0000000..74f9da0
--- /dev/null
+++ b/libqt5xcbqpa-dev/5.9.2/qxcbkeyboard.h
@@ -0,0 +1,151 @@
+/****************************************************************************
+**
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QXCBKEYBOARD_H
+#define QXCBKEYBOARD_H
+
+#include "qxcbobject.h"
+
+#include <xcb/xcb_keysyms.h>
+
+#include <xkbcommon/xkbcommon.h>
+#if QT_CONFIG(xkb)
+#include <xkbcommon/xkbcommon-x11.h>
+#endif
+
+#include <QEvent>
+
+QT_BEGIN_NAMESPACE
+
+class QWindow;
+
+class QXcbKeyboard : public QXcbObject
+{
+public:
+    QXcbKeyboard(QXcbConnection *connection);
+
+    ~QXcbKeyboard();
+
+    void handleKeyPressEvent(const xcb_key_press_event_t *event);
+    void handleKeyReleaseEvent(const xcb_key_release_event_t *event);
+    void handleMappingNotifyEvent(const void *event);
+
+    Qt::KeyboardModifiers translateModifiers(int s) const;
+    void updateKeymap();
+    QList<int> possibleKeys(const QKeyEvent *e) const;
+
+    // when XKEYBOARD not present on the X server
+    void updateXKBMods();
+    quint32 xkbModMask(quint16 state);
+    void updateXKBStateFromCore(quint16 state);
+#ifdef XCB_USE_XINPUT22
+    void updateXKBStateFromXI(void *modInfo, void *groupInfo);
+#endif
+#if QT_CONFIG(xkb)
+    // when XKEYBOARD is present on the X server
+    int coreDeviceId() const { return core_device_id; }
+    void updateXKBState(xcb_xkb_state_notify_event_t *state);
+#endif
+
+protected:
+    void handleKeyEvent(xcb_window_t sourceWindow, QEvent::Type type, xcb_keycode_t code, quint16 state, xcb_timestamp_t time);
+
+    void resolveMaskConflicts();
+    QString lookupString(struct xkb_state *state, xcb_keycode_t code) const;
+    int keysymToQtKey(xcb_keysym_t keysym) const;
+    int keysymToQtKey(xcb_keysym_t keysym, Qt::KeyboardModifiers &modifiers, const QString &text) const;
+    void printKeymapError(const char *error) const;
+
+    void readXKBConfig();
+    void clearXKBConfig();
+    // when XKEYBOARD not present on the X server
+    void updateModifiers();
+    // when XKEYBOARD is present on the X server
+    void updateVModMapping();
+    void updateVModToRModMapping();
+
+    xkb_keysym_t lookupLatinKeysym(xkb_keycode_t keycode) const;
+    void checkForLatinLayout();
+
+private:
+    void updateXKBStateFromState(struct xkb_state *kb_state, quint16 state);
+
+    bool m_config = false;
+    xcb_keycode_t m_autorepeat_code = 0;
+
+    struct xkb_context *xkb_context = nullptr;
+    struct xkb_keymap *xkb_keymap = nullptr;
+    struct xkb_state *xkb_state = nullptr;
+    struct xkb_rule_names xkb_names;
+    mutable struct xkb_keymap *latin_keymap = nullptr;
+
+    struct _mod_masks {
+        uint alt;
+        uint altgr;
+        uint meta;
+        uint super;
+        uint hyper;
+    };
+
+    _mod_masks rmod_masks;
+
+    // when XKEYBOARD not present on the X server
+    xcb_key_symbols_t *m_key_symbols;
+    struct _xkb_mods {
+        xkb_mod_index_t shift;
+        xkb_mod_index_t lock;
+        xkb_mod_index_t control;
+        xkb_mod_index_t mod1;
+        xkb_mod_index_t mod2;
+        xkb_mod_index_t mod3;
+        xkb_mod_index_t mod4;
+        xkb_mod_index_t mod5;
+    };
+    _xkb_mods xkb_mods;
+#if QT_CONFIG(xkb)
+    // when XKEYBOARD is present on the X server
+    _mod_masks vmod_masks;
+    int core_device_id;
+#endif
+    bool m_hasLatinLayout = false;
+};
+
+QT_END_NAMESPACE
+
+#endif
diff --git a/libqt5xcbqpa-dev/5.9.2/qxcbmime.h b/libqt5xcbqpa-dev/5.9.2/qxcbmime.h
new file mode 100644
index 0000000..561631a
--- /dev/null
+++ b/libqt5xcbqpa-dev/5.9.2/qxcbmime.h
@@ -0,0 +1,75 @@
+/****************************************************************************
+**
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QXCBMIME_H
+#define QXCBMIME_H
+
+#include <private/qdnd_p.h>
+
+#include <QtGui/QClipboard>
+
+#include "qxcbintegration.h"
+#include "qxcbconnection.h"
+
+QT_BEGIN_NAMESPACE
+
+#if !(defined(QT_NO_DRAGANDDROP) && defined(QT_NO_CLIPBOARD))
+
+class QXcbMime : public QInternalMimeData {
+    Q_OBJECT
+public:
+    QXcbMime();
+    ~QXcbMime();
+
+    static QVector<xcb_atom_t> mimeAtomsForFormat(QXcbConnection *connection, const QString &format);
+    static QString mimeAtomToString(QXcbConnection *connection, xcb_atom_t a);
+    static bool mimeDataForAtom(QXcbConnection *connection, xcb_atom_t a, QMimeData *mimeData, QByteArray *data,
+                                xcb_atom_t *atomFormat, int *dataFormat);
+    static QVariant mimeConvertToFormat(QXcbConnection *connection, xcb_atom_t a, const QByteArray &data, const QString &format,
+                                        QVariant::Type requestedType, const QByteArray &encoding);
+    static xcb_atom_t mimeAtomForFormat(QXcbConnection *connection, const QString &format, QVariant::Type requestedType,
+                                        const QVector<xcb_atom_t> &atoms, QByteArray *requestedEncoding);
+};
+
+#endif // !(defined(QT_NO_DRAGANDDROP) && defined(QT_NO_CLIPBOARD))
+
+
+QT_END_NAMESPACE
+
+#endif // QXCBMIME_H
diff --git a/libqt5xcbqpa-dev/5.9.2/qxcbnativeinterface.h b/libqt5xcbqpa-dev/5.9.2/qxcbnativeinterface.h
new file mode 100644
index 0000000..4186d77
--- /dev/null
+++ b/libqt5xcbqpa-dev/5.9.2/qxcbnativeinterface.h
@@ -0,0 +1,152 @@
+/****************************************************************************
+**
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QXCBNATIVEINTERFACE_H
+#define QXCBNATIVEINTERFACE_H
+
+#include <qpa/qplatformnativeinterface.h>
+#include <xcb/xcb.h>
+
+#include <QtCore/QRect>
+
+#include "qxcbexport.h"
+
+QT_BEGIN_NAMESPACE
+
+class QWidget;
+class QXcbScreen;
+class QXcbConnection;
+class QXcbNativeInterfaceHandler;
+
+class Q_XCB_EXPORT QXcbNativeInterface : public QPlatformNativeInterface
+{
+    Q_OBJECT
+public:
+    enum ResourceType {
+        Display,
+        Connection,
+        Screen,
+        AppTime,
+        AppUserTime,
+        ScreenHintStyle,
+        StartupId,
+        TrayWindow,
+        GetTimestamp,
+        X11Screen,
+        RootWindow,
+        ScreenSubpixelType,
+        ScreenAntialiasingEnabled,
+        AtspiBus,
+        CompositingEnabled
+    };
+
+    QXcbNativeInterface();
+
+    void *nativeResourceForIntegration(const QByteArray &resource) override;
+    void *nativeResourceForContext(const QByteArray &resourceString, QOpenGLContext *context) override;
+    void *nativeResourceForScreen(const QByteArray &resource, QScreen *screen) override;
+    void *nativeResourceForWindow(const QByteArray &resourceString, QWindow *window) override;
+    void *nativeResourceForBackingStore(const QByteArray &resource, QBackingStore *backingStore) override;
+#ifndef QT_NO_CURSOR
+    void *nativeResourceForCursor(const QByteArray &resource, const QCursor &cursor) override;
+#endif
+
+    NativeResourceForIntegrationFunction nativeResourceFunctionForIntegration(const QByteArray &resource) override;
+    NativeResourceForContextFunction nativeResourceFunctionForContext(const QByteArray &resource) override;
+    NativeResourceForScreenFunction nativeResourceFunctionForScreen(const QByteArray &resource) override;
+    NativeResourceForWindowFunction nativeResourceFunctionForWindow(const QByteArray &resource) override;
+    NativeResourceForBackingStoreFunction nativeResourceFunctionForBackingStore(const QByteArray &resource) override;
+
+    QFunctionPointer platformFunction(const QByteArray &function) const override;
+
+    inline const QByteArray &genericEventFilterType() const { return m_genericEventFilterType; }
+
+    void *displayForWindow(QWindow *window);
+    void *connectionForWindow(QWindow *window);
+    void *screenForWindow(QWindow *window);
+    void *appTime(const QXcbScreen *screen);
+    void *appUserTime(const QXcbScreen *screen);
+    void *getTimestamp(const QXcbScreen *screen);
+    void *startupId();
+    void *x11Screen();
+    void *rootWindow();
+    void *display();
+    void *atspiBus();
+    void *connection();
+    static void setStartupId(const char *);
+    static void setAppTime(QScreen *screen, xcb_timestamp_t time);
+    static void setAppUserTime(QScreen *screen, xcb_timestamp_t time);
+
+    Q_INVOKABLE bool systemTrayAvailable(const QScreen *screen) const;
+    Q_INVOKABLE void setParentRelativeBackPixmap(QWindow *window);
+    Q_INVOKABLE bool systrayVisualHasAlphaChannel();
+    Q_INVOKABLE bool requestSystemTrayWindowDock(const QWindow *window);
+    Q_INVOKABLE QRect systemTrayWindowGlobalGeometry(const QWindow *window);
+
+    void addHandler(QXcbNativeInterfaceHandler *handler);
+    void removeHandler(QXcbNativeInterfaceHandler *handler);
+signals:
+    void systemTrayWindowChanged(QScreen *screen);
+
+private:
+    xcb_window_t locateSystemTray(xcb_connection_t *conn, const QXcbScreen *screen);
+
+    const QByteArray m_genericEventFilterType;
+
+    xcb_atom_t m_sysTraySelectionAtom = XCB_ATOM_NONE;
+
+    static QXcbScreen *qPlatformScreenForWindow(QWindow *window);
+
+    QList<QXcbNativeInterfaceHandler *> m_handlers;
+    NativeResourceForIntegrationFunction handlerNativeResourceFunctionForIntegration(const QByteArray &resource) const;
+    NativeResourceForContextFunction handlerNativeResourceFunctionForContext(const QByteArray &resource) const;
+    NativeResourceForScreenFunction handlerNativeResourceFunctionForScreen(const QByteArray &resource) const;
+    NativeResourceForWindowFunction handlerNativeResourceFunctionForWindow(const QByteArray &resource) const;
+    NativeResourceForBackingStoreFunction handlerNativeResourceFunctionForBackingStore(const QByteArray &resource) const;
+    QFunctionPointer handlerPlatformFunction(const QByteArray &function) const;
+    void *handlerNativeResourceForIntegration(const QByteArray &resource) const;
+    void *handlerNativeResourceForContext(const QByteArray &resource, QOpenGLContext *context) const;
+    void *handlerNativeResourceForScreen(const QByteArray &resource, QScreen *screen) const;
+    void *handlerNativeResourceForWindow(const QByteArray &resource, QWindow *window) const;
+    void *handlerNativeResourceForBackingStore(const QByteArray &resource, QBackingStore *backingStore) const;
+};
+
+QT_END_NAMESPACE
+
+#endif // QXCBNATIVEINTERFACE_H
diff --git a/libqt5xcbqpa-dev/5.9.2/qxcbobject.h b/libqt5xcbqpa-dev/5.9.2/qxcbobject.h
new file mode 100644
index 0000000..1b98d93
--- /dev/null
+++ b/libqt5xcbqpa-dev/5.9.2/qxcbobject.h
@@ -0,0 +1,64 @@
+/****************************************************************************
+**
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QXCBOBJECT_H
+#define QXCBOBJECT_H
+
+#include "qxcbconnection.h"
+
+QT_BEGIN_NAMESPACE
+
+class QXcbObject
+{
+public:
+    QXcbObject(QXcbConnection *connection = 0) : m_connection(connection) {}
+
+    void setConnection(QXcbConnection *connection) { m_connection = connection; }
+    QXcbConnection *connection() const { return m_connection; }
+
+    xcb_atom_t atom(QXcbAtom::Atom atom) const { return m_connection->atom(atom); }
+    xcb_connection_t *xcb_connection() const { return m_connection->xcb_connection(); }
+
+private:
+    QXcbConnection *m_connection;
+};
+
+QT_END_NAMESPACE
+
+#endif
diff --git a/libqt5xcbqpa-dev/5.9.2/qxcbscreen.h b/libqt5xcbqpa-dev/5.9.2/qxcbscreen.h
new file mode 100644
index 0000000..4163be2
--- /dev/null
+++ b/libqt5xcbqpa-dev/5.9.2/qxcbscreen.h
@@ -0,0 +1,220 @@
+/****************************************************************************
+**
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QXCBSCREEN_H
+#define QXCBSCREEN_H
+
+#include <qpa/qplatformscreen.h>
+#include <QtCore/QString>
+
+#include <xcb/xcb.h>
+#include <xcb/randr.h>
+#include <xcb/xfixes.h>
+#include <xcb/xinerama.h>
+
+#include "qxcbobject.h"
+#include "qxcbscreen.h"
+
+#include <private/qfontengine_p.h>
+
+QT_BEGIN_NAMESPACE
+
+class QXcbConnection;
+class QXcbCursor;
+class QXcbXSettings;
+#ifndef QT_NO_DEBUG_STREAM
+class QDebug;
+#endif
+
+class QXcbVirtualDesktop : public QXcbObject
+{
+public:
+    QXcbVirtualDesktop(QXcbConnection *connection, xcb_screen_t *screen, int number);
+    ~QXcbVirtualDesktop();
+
+    xcb_screen_t *screen() const { return m_screen; }
+    int number() const { return m_number; }
+    QSize size() const { return QSize(m_screen->width_in_pixels, m_screen->height_in_pixels); }
+    QSize physicalSize() const { return QSize(m_screen->width_in_millimeters, m_screen->height_in_millimeters); }
+    xcb_window_t root() const { return m_screen->root; }
+    QXcbScreen *screenAt(const QPoint &pos) const;
+
+    QList<QPlatformScreen *> screens() const { return m_screens; }
+    void setScreens(QList<QPlatformScreen *> sl) { m_screens = sl; }
+    void removeScreen(QPlatformScreen *s) { m_screens.removeOne(s); }
+    void addScreen(QPlatformScreen *s);
+    void setPrimaryScreen(QPlatformScreen *s);
+
+    QXcbXSettings *xSettings() const;
+
+    bool compositingActive() const;
+
+    QRect workArea() const { return m_workArea; }
+    void updateWorkArea();
+
+    void handleXFixesSelectionNotify(xcb_xfixes_selection_notify_event_t *notify_event);
+    void subscribeToXFixesSelectionNotify();
+
+private:
+    QRect getWorkArea() const;
+
+    xcb_screen_t *m_screen;
+    const int m_number;
+    QList<QPlatformScreen *> m_screens;
+
+    QXcbXSettings *m_xSettings = nullptr;
+    xcb_atom_t m_net_wm_cm_atom = 0;
+    bool m_compositingActive = false;
+
+    QRect m_workArea;
+};
+
+class Q_XCB_EXPORT QXcbScreen : public QXcbObject, public QPlatformScreen
+{
+public:
+    QXcbScreen(QXcbConnection *connection, QXcbVirtualDesktop *virtualDesktop,
+               xcb_randr_output_t outputId, xcb_randr_get_output_info_reply_t *outputInfo,
+               const xcb_xinerama_screen_info_t *xineramaScreenInfo = Q_NULLPTR, int xineramaScreenIdx = -1);
+    ~QXcbScreen();
+
+    QString getOutputName(xcb_randr_get_output_info_reply_t *outputInfo);
+
+    QPixmap grabWindow(WId window, int x, int y, int width, int height) const override;
+
+    QWindow *topLevelAt(const QPoint &point) const override;
+
+    QRect geometry() const override { return m_geometry; }
+    QRect availableGeometry() const override {return m_availableGeometry;}
+    int depth() const override { return screen()->root_depth; }
+    QImage::Format format() const override;
+    QSizeF physicalSize() const override { return m_sizeMillimeters; }
+    QSize virtualSize() const { return m_virtualSize; }
+    QSizeF physicalVirtualSize() const { return m_virtualSizeMillimeters; }
+    QDpi virtualDpi() const;
+    QDpi logicalDpi() const override;
+    qreal pixelDensity() const override;
+    QPlatformCursor *cursor() const override;
+    qreal refreshRate() const override { return m_refreshRate; }
+    Qt::ScreenOrientation orientation() const override { return m_orientation; }
+    QList<QPlatformScreen *> virtualSiblings() const override { return m_virtualDesktop->screens(); }
+    QXcbVirtualDesktop *virtualDesktop() const { return m_virtualDesktop; }
+
+    void setPrimary(bool primary) { m_primary = primary; }
+    bool isPrimary() const { return m_primary; }
+
+    int screenNumber() const { return m_virtualDesktop->number(); }
+    static int virtualDesktopNumberStatic(const QScreen *screen);
+
+    xcb_screen_t *screen() const { return m_virtualDesktop->screen(); }
+    xcb_window_t root() const { return screen()->root; }
+    xcb_randr_output_t output() const { return m_output; }
+    xcb_randr_crtc_t crtc() const { return m_crtc; }
+    xcb_randr_mode_t mode() const { return m_mode; }
+
+    void setOutput(xcb_randr_output_t outputId,
+                   xcb_randr_get_output_info_reply_t *outputInfo);
+    void setCrtc(xcb_randr_crtc_t crtc) { m_crtc = crtc; }
+
+    void windowShown(QXcbWindow *window);
+    QString windowManagerName() const { return m_windowManagerName; }
+    bool syncRequestSupported() const { return m_syncRequestSupported; }
+
+    QSurfaceFormat surfaceFormatFor(const QSurfaceFormat &format) const;
+
+    const xcb_visualtype_t *visualForFormat(const QSurfaceFormat &format) const;
+    const xcb_visualtype_t *visualForId(xcb_visualid_t) const;
+    quint8 depthOfVisual(xcb_visualid_t) const;
+
+    QString name() const override { return m_outputName; }
+
+    void handleScreenChange(xcb_randr_screen_change_notify_event_t *change_event);
+    void updateGeometry(const QRect &geom, uint8_t rotation);
+    void updateGeometry(xcb_timestamp_t timestamp = XCB_TIME_CURRENT_TIME);
+    void updateAvailableGeometry();
+    void updateRefreshRate(xcb_randr_mode_t mode);
+
+    void readXResources();
+
+    QFontEngine::HintStyle hintStyle() const { return m_hintStyle; }
+    QFontEngine::SubpixelAntialiasingType subpixelType() const { return m_subpixelType; }
+    int antialiasingEnabled() const { return m_antialiasingEnabled; }
+
+    QXcbXSettings *xSettings() const;
+
+private:
+    static bool xResource(const QByteArray &identifier,
+                          const QByteArray &expectedIdentifier,
+                          QByteArray &stringValue);
+    void sendStartupMessage(const QByteArray &message) const;
+
+    QXcbVirtualDesktop *m_virtualDesktop;
+    xcb_randr_output_t m_output;
+    xcb_randr_crtc_t m_crtc;
+    xcb_randr_mode_t m_mode = XCB_NONE;
+    bool m_primary = false;
+    uint8_t m_rotation = XCB_RANDR_ROTATION_ROTATE_0;
+
+    QString m_outputName;
+    QSizeF m_outputSizeMillimeters;
+    QSizeF m_sizeMillimeters;
+    QRect m_geometry;
+    QRect m_availableGeometry;
+    QSize m_virtualSize;
+    QSizeF m_virtualSizeMillimeters;
+    Qt::ScreenOrientation m_orientation = Qt::PrimaryOrientation;
+    QString m_windowManagerName;
+    bool m_syncRequestSupported = false;
+    QMap<xcb_visualid_t, xcb_visualtype_t> m_visuals;
+    QMap<xcb_visualid_t, quint8> m_visualDepths;
+    QXcbCursor *m_cursor;
+    int m_refreshRate = 60;
+    int m_forcedDpi = -1;
+    int m_pixelDensity = 1;
+    QFontEngine::HintStyle m_hintStyle = QFontEngine::HintStyle(-1);
+    QFontEngine::SubpixelAntialiasingType m_subpixelType = QFontEngine::SubpixelAntialiasingType(-1);
+    int m_antialiasingEnabled = -1;
+};
+
+#ifndef QT_NO_DEBUG_STREAM
+Q_GUI_EXPORT QDebug operator<<(QDebug, const QXcbScreen *);
+#endif
+
+QT_END_NAMESPACE
+
+#endif
diff --git a/libqt5xcbqpa-dev/5.9.2/qxcbsessionmanager.h b/libqt5xcbqpa-dev/5.9.2/qxcbsessionmanager.h
new file mode 100644
index 0000000..0ad9445
--- /dev/null
+++ b/libqt5xcbqpa-dev/5.9.2/qxcbsessionmanager.h
@@ -0,0 +1,96 @@
+/****************************************************************************
+**
+** Copyright (C) 2013 Teo Mrnjavac <teo@kde.org>
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QXCBSESSIONMANAGER_H
+#define QXCBSESSIONMANAGER_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is part of the QPA API and is not meant to be used
+// in applications. Usage of this API may make your code
+// source and binary incompatible with future versions of Qt.
+//
+
+#include <qpa/qplatformsessionmanager.h>
+
+#ifndef QT_NO_SESSIONMANAGER
+
+QT_BEGIN_NAMESPACE
+
+class QEventLoop;
+
+class QXcbSessionManager : public QPlatformSessionManager
+{
+public:
+    QXcbSessionManager(const QString &id, const QString &key);
+    virtual ~QXcbSessionManager();
+
+    void *handle() const;
+
+    void setSessionId(const QString &id) { m_sessionId = id; }
+    void setSessionKey(const QString &key) { m_sessionKey = key; }
+
+    bool allowsInteraction() override;
+    bool allowsErrorInteraction() override;
+    void release() override;
+
+    void cancel() override;
+
+    void setManagerProperty(const QString &name, const QString &value) override;
+    void setManagerProperty(const QString &name, const QStringList &value) override;
+
+    bool isPhase2() const override;
+    void requestPhase2() override;
+
+    void exitEventLoop();
+
+private:
+    QEventLoop *m_eventLoop;
+
+    Q_DISABLE_COPY(QXcbSessionManager)
+};
+
+QT_END_NAMESPACE
+
+#endif //QT_NO_SESSIONMANAGER
+
+#endif //QXCBSESSIONMANAGER_H
diff --git a/libqt5xcbqpa-dev/5.9.2/qxcbsystemtraytracker.h b/libqt5xcbqpa-dev/5.9.2/qxcbsystemtraytracker.h
new file mode 100644
index 0000000..a95b937
--- /dev/null
+++ b/libqt5xcbqpa-dev/5.9.2/qxcbsystemtraytracker.h
@@ -0,0 +1,85 @@
+/****************************************************************************
+**
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QXCBSYSTEMTRAYTRACKER_H
+#define QXCBSYSTEMTRAYTRACKER_H
+
+#include "qxcbconnection.h"
+
+#include <xcb/xcb.h>
+
+QT_BEGIN_NAMESPACE
+
+class QXcbConnection;
+class QScreen;
+
+class QXcbSystemTrayTracker : public QObject, public QXcbWindowEventListener
+{
+    Q_OBJECT
+public:
+    static QXcbSystemTrayTracker *create(QXcbConnection *connection);
+
+    xcb_window_t trayWindow();
+    void requestSystemTrayWindowDock(xcb_window_t window) const;
+    QRect systemTrayWindowGlobalGeometry(xcb_window_t window) const;
+
+    void notifyManagerClientMessageEvent(const xcb_client_message_event_t *);
+
+    void handleDestroyNotifyEvent(const xcb_destroy_notify_event_t *) override;
+
+    bool visualHasAlphaChannel();
+signals:
+    void systemTrayWindowChanged(QScreen *screen);
+
+private:
+    explicit QXcbSystemTrayTracker(QXcbConnection *connection,
+                                   xcb_atom_t trayAtom,
+                                   xcb_atom_t selection);
+    static xcb_window_t locateTrayWindow(const QXcbConnection *connection, xcb_atom_t selection);
+    void emitSystemTrayWindowChanged();
+
+    const xcb_atom_t m_selection;
+    const xcb_atom_t m_trayAtom;
+    QXcbConnection *m_connection;
+    xcb_window_t m_trayWindow = 0;
+};
+
+QT_END_NAMESPACE
+
+#endif // QXCBSYSTEMTRAYTRACKER_H
diff --git a/libqt5xcbqpa-dev/5.9.2/qxcbwindow.h b/libqt5xcbqpa-dev/5.9.2/qxcbwindow.h
new file mode 100644
index 0000000..f38343b
--- /dev/null
+++ b/libqt5xcbqpa-dev/5.9.2/qxcbwindow.h
@@ -0,0 +1,297 @@
+/****************************************************************************
+**
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QXCBWINDOW_H
+#define QXCBWINDOW_H
+
+#include <qpa/qplatformwindow.h>
+#include <QtGui/QSurfaceFormat>
+#include <QtGui/QImage>
+
+#include <xcb/xcb.h>
+#include <xcb/sync.h>
+
+#include "qxcbobject.h"
+
+#include <QtPlatformHeaders/qxcbwindowfunctions.h>
+
+QT_BEGIN_NAMESPACE
+
+class QXcbScreen;
+class QXcbSyncWindowRequest;
+class QIcon;
+
+class Q_XCB_EXPORT QXcbWindow : public QXcbObject, public QXcbWindowEventListener, public QPlatformWindow
+{
+public:
+    enum NetWmState {
+        NetWmStateAbove = 0x1,
+        NetWmStateBelow = 0x2,
+        NetWmStateFullScreen = 0x4,
+        NetWmStateMaximizedHorz = 0x8,
+        NetWmStateMaximizedVert = 0x10,
+        NetWmStateModal = 0x20,
+        NetWmStateStaysOnTop = 0x40,
+        NetWmStateDemandsAttention = 0x80
+    };
+
+    Q_DECLARE_FLAGS(NetWmStates, NetWmState)
+
+    QXcbWindow(QWindow *window);
+    ~QXcbWindow();
+
+    void setGeometry(const QRect &rect) override;
+
+    QMargins frameMargins() const override;
+
+    void setVisible(bool visible) override;
+    void setWindowFlags(Qt::WindowFlags flags) override;
+    void setWindowState(Qt::WindowState state) override;
+    WId winId() const override;
+    void setParent(const QPlatformWindow *window) override;
+
+    bool isExposed() const override;
+    bool isEmbedded() const override;
+    QPoint mapToGlobal(const QPoint &pos) const override;
+    QPoint mapFromGlobal(const QPoint &pos) const override;
+
+    void setWindowTitle(const QString &title) override;
+    void setWindowIconText(const QString &title);
+    void setWindowIcon(const QIcon &icon) override;
+    void raise() override;
+    void lower() override;
+    void propagateSizeHints() override;
+
+    void requestActivateWindow() override;
+
+    bool setKeyboardGrabEnabled(bool grab) override;
+    bool setMouseGrabEnabled(bool grab) override;
+
+    void setCursor(xcb_cursor_t cursor, bool isBitmapCursor);
+
+    QSurfaceFormat format() const override;
+
+    void windowEvent(QEvent *event) override;
+
+    bool startSystemResize(const QPoint &pos, Qt::Corner corner) override;
+
+    void setOpacity(qreal level) override;
+    void setMask(const QRegion &region) override;
+
+    void setAlertState(bool enabled) override;
+    bool isAlertState() const override { return m_alertState; }
+
+    xcb_window_t xcb_window() const { return m_window; }
+    uint depth() const { return m_depth; }
+    QImage::Format imageFormat() const { return m_imageFormat; }
+    bool imageNeedsRgbSwap() const { return m_imageRgbSwap; }
+
+    bool handleGenericEvent(xcb_generic_event_t *event, long *result)  override;
+
+    void handleExposeEvent(const xcb_expose_event_t *event) override;
+    void handleClientMessageEvent(const xcb_client_message_event_t *event) override;
+    void handleConfigureNotifyEvent(const xcb_configure_notify_event_t *event) override;
+    void handleMapNotifyEvent(const xcb_map_notify_event_t *event) override;
+    void handleUnmapNotifyEvent(const xcb_unmap_notify_event_t *event) override;
+    void handleButtonPressEvent(const xcb_button_press_event_t *event) override;
+    void handleButtonReleaseEvent(const xcb_button_release_event_t *event) override;
+    void handleMotionNotifyEvent(const xcb_motion_notify_event_t *event) override;
+
+    void handleEnterNotifyEvent(const xcb_enter_notify_event_t *event) override;
+    void handleLeaveNotifyEvent(const xcb_leave_notify_event_t *event) override;
+    void handleFocusInEvent(const xcb_focus_in_event_t *event) override;
+    void handleFocusOutEvent(const xcb_focus_out_event_t *event) override;
+    void handlePropertyNotifyEvent(const xcb_property_notify_event_t *event) override;
+#ifdef XCB_USE_XINPUT22
+    void handleXIMouseEvent(xcb_ge_event_t *, Qt::MouseEventSource source = Qt::MouseEventNotSynthesized) override;
+    void handleXIEnterLeave(xcb_ge_event_t *) override;
+#endif
+
+    QXcbWindow *toWindow() override;
+
+    void handleMouseEvent(xcb_timestamp_t time, const QPoint &local, const QPoint &global,
+                          Qt::KeyboardModifiers modifiers, Qt::MouseEventSource source);
+
+    void updateNetWmUserTime(xcb_timestamp_t timestamp);
+
+    static void setWmWindowTypeStatic(QWindow *window, QXcbWindowFunctions::WmWindowTypes windowTypes);
+    static void setWmWindowRoleStatic(QWindow *window, const QByteArray &role);
+    static uint visualIdStatic(QWindow *window);
+
+    QXcbWindowFunctions::WmWindowTypes wmWindowTypes() const;
+    void setWmWindowType(QXcbWindowFunctions::WmWindowTypes types, Qt::WindowFlags flags);
+    void setWmWindowRole(const QByteArray &role);
+
+    static void setWindowIconTextStatic(QWindow *window, const QString &text);
+
+    static void setParentRelativeBackPixmapStatic(QWindow *window);
+    void setParentRelativeBackPixmap();
+
+    static bool requestSystemTrayWindowDockStatic(const QWindow *window);
+    bool requestSystemTrayWindowDock() const;
+
+    static QRect systemTrayWindowGlobalGeometryStatic(const QWindow *window);
+    QRect systemTrayWindowGlobalGeometry() const;
+    uint visualId() const;
+
+    bool needsSync() const;
+
+    void postSyncWindowRequest();
+    void clearSyncWindowRequest() { m_pendingSyncRequest = 0; }
+
+    QXcbScreen *xcbScreen() const;
+
+    bool doStartSystemResize(const QPoint &globalPos, Qt::Corner corner);
+
+    virtual void create();
+    virtual void destroy();
+
+public Q_SLOTS:
+    void updateSyncRequestCounter();
+
+protected:
+    virtual void resolveFormat(const QSurfaceFormat &format) { m_format = format; }
+    virtual const xcb_visualtype_t *createVisual();
+
+    QXcbScreen *parentScreen();
+
+    QXcbScreen *initialScreen() const;
+    void changeNetWmState(bool set, xcb_atom_t one, xcb_atom_t two = 0);
+    NetWmStates netWmStates();
+    void setNetWmStates(NetWmStates);
+
+    void setMotifWindowFlags(Qt::WindowFlags flags);
+    void setNetWmStateWindowFlags(Qt::WindowFlags flags);
+
+    void updateMotifWmHintsBeforeMap();
+    void updateNetWmStateBeforeMap();
+
+    void setTransparentForMouseEvents(bool transparent);
+    void updateDoesNotAcceptFocus(bool doesNotAcceptFocus);
+
+    QRect windowToWmGeometry(QRect r) const;
+    void sendXEmbedMessage(xcb_window_t window, quint32 message,
+                           quint32 detail = 0, quint32 data1 = 0, quint32 data2 = 0);
+    void handleXEmbedMessage(const xcb_client_message_event_t *event);
+
+    void show();
+    void hide();
+
+    bool relayFocusToModalWindow() const;
+    void doFocusIn();
+    void doFocusOut();
+
+    bool compressExposeEvent(QRegion &exposeRegion);
+
+    void handleButtonPressEvent(int event_x, int event_y, int root_x, int root_y,
+                                int detail, Qt::KeyboardModifiers modifiers, xcb_timestamp_t timestamp, Qt::MouseEventSource source = Qt::MouseEventNotSynthesized);
+
+    void handleButtonReleaseEvent(int event_x, int event_y, int root_x, int root_y,
+                                  int detail, Qt::KeyboardModifiers modifiers, xcb_timestamp_t timestamp, Qt::MouseEventSource source = Qt::MouseEventNotSynthesized);
+
+    void handleMotionNotifyEvent(int event_x, int event_y, int root_x, int root_y,
+                                 Qt::KeyboardModifiers modifiers, xcb_timestamp_t timestamp, Qt::MouseEventSource source = Qt::MouseEventNotSynthesized);
+
+    void handleEnterNotifyEvent(int event_x, int event_y, int root_x, int root_y,
+                                quint8 mode, quint8 detail, xcb_timestamp_t timestamp);
+
+    void handleLeaveNotifyEvent(int root_x, int root_y,
+                                quint8 mode, quint8 detail, xcb_timestamp_t timestamp);
+
+    xcb_window_t m_window = 0;
+    xcb_colormap_t m_cmap = 0;
+
+    uint m_depth = 0;
+    QImage::Format m_imageFormat = QImage::Format_ARGB32_Premultiplied;
+    bool m_imageRgbSwap = false;
+
+    xcb_sync_int64_t m_syncValue;
+    xcb_sync_counter_t m_syncCounter = 0;
+
+    Qt::WindowState m_windowState = Qt::WindowNoState;
+
+    xcb_gravity_t m_gravity = XCB_GRAVITY_STATIC;
+
+    bool m_mapped = false;
+    bool m_transparent = false;
+    bool m_usingSyncProtocol = false;
+    bool m_deferredActivation = false;
+    bool m_embedded = false;
+    bool m_alertState = false;
+    xcb_window_t m_netWmUserTimeWindow = XCB_NONE;
+
+    QSurfaceFormat m_format;
+
+    mutable bool m_dirtyFrameMargins = false;
+    mutable QMargins m_frameMargins;
+
+    QRegion m_exposeRegion;
+    QSize m_oldWindowSize;
+
+    xcb_visualid_t m_visualId = 0;
+    int m_lastWindowStateEvent = -1;
+
+    enum SyncState {
+        NoSyncNeeded,
+        SyncReceived,
+        SyncAndConfigureReceived
+    };
+    SyncState m_syncState = NoSyncNeeded;
+
+    QXcbSyncWindowRequest *m_pendingSyncRequest = nullptr;
+    xcb_cursor_t m_currentBitmapCursor = XCB_CURSOR_NONE;
+};
+
+class QXcbForeignWindow : public QXcbWindow
+{
+public:
+    QXcbForeignWindow(QWindow *window, WId nativeHandle)
+        : QXcbWindow(window) { m_window = nativeHandle; }
+    ~QXcbForeignWindow();
+    bool isForeignWindow() const override { return true; }
+
+protected:
+    void create() override {} // No-op
+};
+
+QT_END_NAMESPACE
+
+Q_DECLARE_METATYPE(QXcbWindow*)
+
+#endif
diff --git a/libqt5xcbqpa-dev/5.9.2/qxcbwmsupport.h b/libqt5xcbqpa-dev/5.9.2/qxcbwmsupport.h
new file mode 100644
index 0000000..b5de5b7
--- /dev/null
+++ b/libqt5xcbqpa-dev/5.9.2/qxcbwmsupport.h
@@ -0,0 +1,68 @@
+/****************************************************************************
+**
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#ifndef QXCBWMSUPPORT_H
+#define QXCBWMSUPPORT_H
+
+#include "qxcbobject.h"
+#include "qxcbconnection.h"
+#include <qvector.h>
+
+QT_BEGIN_NAMESPACE
+
+class QXcbWMSupport : public QXcbObject
+{
+public:
+    QXcbWMSupport(QXcbConnection *c);
+
+
+    bool isSupportedByWM(xcb_atom_t atom) const;
+    const QVector<xcb_window_t> &virtualRoots() const { return net_virtual_roots; }
+
+private:
+    friend class QXcbConnection;
+    void updateNetWMAtoms();
+    void updateVirtualRoots();
+
+    QVector<xcb_atom_t> net_wm_atoms;
+    QVector<xcb_window_t> net_virtual_roots;
+};
+
+QT_END_NAMESPACE
+
+#endif
diff --git a/libqt5xcbqpa-dev/5.9.2/qxcbxsettings.h b/libqt5xcbqpa-dev/5.9.2/qxcbxsettings.h
new file mode 100644
index 0000000..ab1f784
--- /dev/null
+++ b/libqt5xcbqpa-dev/5.9.2/qxcbxsettings.h
@@ -0,0 +1,71 @@
+/****************************************************************************
+**
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QXCBXSETTINGS_H
+#define QXCBXSETTINGS_H
+
+#include "qxcbscreen.h"
+
+QT_BEGIN_NAMESPACE
+
+class QXcbXSettingsPrivate;
+
+class QXcbXSettings : public QXcbWindowEventListener
+{
+    Q_DECLARE_PRIVATE(QXcbXSettings)
+public:
+    QXcbXSettings(QXcbVirtualDesktop *screen);
+    ~QXcbXSettings();
+    bool initialized() const;
+
+    QVariant setting(const QByteArray &property) const;
+
+    typedef void (*PropertyChangeFunc)(QXcbVirtualDesktop *screen, const QByteArray &name, const QVariant &property, void *handle);
+    void registerCallbackForProperty(const QByteArray &property, PropertyChangeFunc func, void *handle);
+    void removeCallbackForHandle(const QByteArray &property, void *handle);
+    void removeCallbackForHandle(void *handle);
+
+    void handlePropertyNotifyEvent(const xcb_property_notify_event_t *event) override;
+private:
+    QXcbXSettingsPrivate *d_ptr;
+};
+
+QT_END_NAMESPACE
+
+#endif // QXCBXSETTINGS_H
